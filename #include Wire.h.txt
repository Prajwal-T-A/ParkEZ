#include <Wire.h>
#include "I2CKeyPad.h"
#include <Adafruit_NeoPixel.h>
#include <Adafruit_PWMServoDriver.h>
#include <TFT_eSPI.h>
#include <WiFi.h>
#include <WebServer.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <HTTPClient.h>

// WiFi Credentials
const char* ssid = "iPhone";
const char* password = "vineeta1271";

// ThingSpeak Details
const char* thingSpeakServer = "http://api.thingspeak.com/update";
const char* thingSpeakAPIKey = "RJSOAJJS1CD1BL75";

// Web server and time setup
WebServer server(80);
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 19800, 60000); // UTC+5:30 IST

// Keypad and I2C
#define KEYPAD_ADDRESS 0x3D
#define PROXIMITY_ADDRESS 0x3A
I2CKeyPad keyPad(KEYPAD_ADDRESS);
char keys[] = "147*2580369#ABCDNF";

// TFT Display
TFT_eSPI tft = TFT_eSPI();
int cursorY = 2;

// NeoPixel
#define PIN_WS2812B 17
Adafruit_NeoPixel ws2812b(1, PIN_WS2812B, NEO_GRB + NEO_KHZ800);

// Servo
Adafruit_PWMServoDriver pca9685 = Adafruit_PWMServoDriver(0x40);
#define SERVO_PIN 0
#define SERVOMIN 100
#define SERVOMAX 500

// Access System Variables
String enteredPIN = "";
String correctPIN = "1234";
bool accessGranted = false;
bool carDetected = false;
bool slotOccupied = false;

int accessAttempts = 0;
int unauthorizedEvents = 0;

#define MAX_LOGS 7
String accessLogs[MAX_LOGS];
int logIndex = 0;

void addLog(String status) {
  timeClient.update();
  String timestamp = timeClient.getFormattedTime();
  String log = timestamp + " - " + status;
  accessLogs[logIndex % MAX_LOGS] = log;
  logIndex++;
}

void sendToThingSpeak() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    String url = String(thingSpeakServer) + "?api_key=" + thingSpeakAPIKey +
                 "&field1=" + String(slotOccupied ? 1 : 0) +
                 "&field2=" + String(accessAttempts) +
                 "&field3=" + String(unauthorizedEvents);
    http.begin(url);
    int response = http.GET();
    Serial.print("ThingSpeak Response: ");
    Serial.println(response);
    http.end();
  } else {
    Serial.println("WiFi Disconnected - ThingSpeak not updated");
  }
}

void handleSlotStatus() {
  server.send(200, "text/plain", slotOccupied ? "1" : "0");
}

void handleAccessLogs() {
  String json = "[";
  int start = max(0, logIndex - MAX_LOGS);
  for (int i = start; i < logIndex; i++) {
    if (i > start) json += ",";
    String logStr = accessLogs[i % MAX_LOGS];
    int sep = logStr.indexOf(" - ");
    String time = logStr.substring(0, sep);
    String status = logStr.substring(sep + 3);
    json += "{\"time\":\"" + time + "\",\"status\":\"" + status + "\"}";
  }
  json += "]";
  server.send(200, "application/json", json);
}

void setup() {
  Serial.begin(115200);
  Wire.begin();

  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\n WiFi connected!");
  Serial.print("ESP32 IP address: ");
  Serial.println(WiFi.localIP());

  timeClient.begin();
  server.on("/slotStatus", handleSlotStatus);
  server.on("/accessLogs", handleAccessLogs);
  server.begin();

  if (!keyPad.begin()) {
    Serial.println("\n ERROR: Keypad not found.");
    while (1);
  }

  tft.init();
  tft.setRotation(3);
  tft.fillScreen(TFT_WHITE);
  tft.setTextColor(TFT_BLACK, TFT_WHITE);
  tft.setTextSize(2);
  tft.setCursor(0, cursorY);
  tft.println("System Ready");
  cursorY += 20;

  ws2812b.begin();
  ws2812b.setBrightness(100);
  ws2812b.clear();
  ws2812b.show();

  pca9685.begin();
  pca9685.setPWMFreq(50);
  moveServo(0);
}

void blinkNeoPixel(uint8_t r, uint8_t g, uint8_t b) {
  ws2812b.setPixelColor(0, ws2812b.Color(r, g, b));
  ws2812b.show();
}

void moveServo(int angle) {
  int pulse = map(angle, 0, 180, SERVOMIN, SERVOMAX);
  pca9685.setPWM(SERVO_PIN, 0, pulse);
}

void displayLine(String msg) {
  if (cursorY > 200) {
    tft.fillScreen(TFT_WHITE);
    cursorY = 2;
  }
  tft.fillRect(0, cursorY, 240, 20, TFT_WHITE);
  tft.setCursor(0, cursorY);
  tft.println(msg);
  cursorY += 20;
}

char readKeypad() {
  uint8_t idx = keyPad.getKey();
  if (keys[idx] != 'N') {
    delay(300);
    return keys[idx];
  }
  return '\0';
}

bool isCarPresent() {
  Wire.requestFrom(PROXIMITY_ADDRESS, 1);
  if (Wire.available()) {
    byte sensorByte = Wire.read();
    Serial.print(" Sensor Byte: ");
    Serial.println(sensorByte, BIN);
    return (sensorByte != 0xFF);
  }
  return false;
}

void loop() {
  server.handleClient();
  carDetected = isCarPresent();

  if (carDetected && !accessGranted) {
    displayLine("Car Detected!");
    displayLine(" Enter PIN:");
    accessGranted = true;
  }

  char key = readKeypad();
  if (key != '\0') {
    displayLine("Key: " + String(key));

    if (key == '#') {
      accessAttempts++;
      if (enteredPIN == correctPIN && carDetected) {
        displayLine("Access Granted");
        blinkNeoPixel(0, 255, 0);
        moveServo(90);
        slotOccupied = true;
        addLog("Access Granted");
      } else {
        displayLine(" Access Denied");
        blinkNeoPixel(255, 0, 0);
        enteredPIN = "";
        accessGranted = false;
        slotOccupied = false;
        unauthorizedEvents++;
        addLog("Access Denied");
      }

      // Push to ThingSpeak
      sendToThingSpeak();
    } else if (key == '*') {
      enteredPIN = "";
      displayLine("PIN Cleared");
    } else {
      enteredPIN += key;
    }
  }

  if (!carDetected && accessGranted) {
    displayLine(" Car Left - Gate Closing");
    moveServo(0);
    ws2812b.clear();
    ws2812b.show();
    accessGranted = false;
    enteredPIN = "";
    slotOccupied = false;

    // Also push update
    sendToThingSpeak();
  }

  // Periodic update every 60 sec
  static unsigned long lastUpdate = 0;
  if (millis() - lastUpdate > 60000) {
    sendToThingSpeak();
    lastUpdate = millis();
  }

  delay(300);
}